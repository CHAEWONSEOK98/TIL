# JavaScript Promise

## 배경

싱글 스레드 방식으로 동작하는 자바스크립트는 현재 실행중인 작업과는 별도로 다른 작업을 수행할 때 비동기 처리 방식을 사용한다. 그리고 비동기 작업의 결과에 따라 다른 작업을 수행해야 할 때는 전통적으로 콜백 함수를 사용했다. 그러나 콜백 함수를 사용하면 코드가 복잡해지고 가독성이 떨어지는 문제가 발생하는 경우도 빈번했으며 콜백 지옥 현상을 마주했다.

<hr />

## Promise?

- 비동기를 순차적으로 처리하기 위해 사용된 콜백 함수**방식**에서 발전된 형태
- 자바스크립트의 Promise 객체는 비동기 처리를 위한 전용 객체다.
- 비동기 작업의 성공 또는 실패와 그 결과값을 객체로 나타낸다.
- 결과적으로 비동기 작업의 흐름을 좀더 직관적으로 나타낼 수 있다.

<hr />

## Promise 사용

**프로미스 객체 생성**

- Promise 객체를 생성하려면 new 키워드와 Promise 생성자 함수를 사용
- Promise 생성자 안에 두개의 매개변수를 가진 콜백 함수를 넣게 되는데, 첫 번째 인수는 작업이 성공했을 때 성공(resolve)임을 알려주는 객체이며, 두 번째 인수는 작업이 실패했을 때 실패(reject)임을 알려주는 오류 객체

**프로미스 객체 처리**

- 만들어진 Promise 객체는 비동기 작업이 완료된 이후 작업 결과에 따라 **.then()** 과 **.catch()** 메서드 체이닝을 통해 성공과 실패에 대한 후속 처리를 진행
- **.then()** > 호출한 resolve() 함수의 매개변수의 값이 콜백 함수 인자로 전달되어 then 메서드 내부에서 프로미스 객체 내부에서 다룬 값을 사용
- **.catch()** > 처리가 실패한 경우 프로미스 객체 내부에서 rejcet() 처리

```
learnPromise
  .then((value) => { // 성공했을 때 실행되는 코드
    console.log('성공적으로 받은 데이터', value);
  })
  .catch((error) => { // 실패했을 때 실행되는 코드
    console.error(error);
  })
  .finally(() => {}); // 무조건 실행되는 코드
```

**프로미스 함수 등록**  
`생성된 프로미스 객체를 함수 반환값으로 사용하는 이유 재사용성, 가독성, 확장성 고려`

```
// 프로미스 객체를 반환하는 함수 생성
function myPromise() {
  return new Promise((resolve, reject) => {
    if (/* 성공 조건 */) {
      resolve(/* 결과 값 */);
    } else {
      reject(/* 에러 값 */);
    }
  });
}

// 프로미스 객체를 반환하는 함수 사용
myPromise()
    .then((result) => {
      // 성공 시 실행할 콜백 함수
    })
    .catch((error) => {
      // 실패 시 실행할 콜백 함수
    });
```

<hr />

## Promise 3가지 상태

**프로미스 처리 과정**

- Pending(대기) : 처리가 완료되지 않은 상태 (진행)
- Fullfilled(이행) : 성공적으로 처리가 완료된 상태
- Rejected(거부) : 처리가 실패로 끝난 상태

<hr />

## Promise 핸들러

- then() : 프로미스가 이행(fulfilled)되었을 때 실행할 콜백 함수를 등록하고, 새로운 프로미스를 반환
- catch() : 프로미스가 거부(rejected)되었을 때 실행할 콜백 함수를 등록하고, 새로운 프로미스를 반환
- finally() : 상태 상관없이 실행할 콜백 함수를 등록하고, 새로운 프로미스를 반환

<hr />

## Promise 체이닝

> 프로미스 체이닝이란, 프로미스 핸들러를 연달아 연결하는 것을 말한다. 이렇게 하면 여러 개의 비동기 작업을 순차적으로 수행할 수 있다는 특징이 있다.

> 체이닝이 가능한 이유는 then 핸들러에서 값을 리턴하면, 그 반환값은 자동으로 프로미스 객체로 감싸져 반환되기 때문이다. 그리고 다음 then 핸들러에서 반환된 프로미스 객체를 받아 처리하는 것이다.

<hr />

## 한계

- 콜백 못지않게 프로미스의 then() 메서드가 지나치게 체인되어 반복되면 가독성이 떨어진다.
- then() 메서드를 체이닝하였을 때 코드가 길어질수록 then 메서드가 어떤 값을 반환하는지 파악하기 어렵다.
- 체이닝 할 때마다 catch 메서드를 각각 사용하지 않으면 중간에 발생할 수 있는 에러나 예외 상황에 대응하기 어렵다.
